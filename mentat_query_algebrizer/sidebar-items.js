initSidebarItems({"enum":[["AlgebrizerError",""],["BindingError",""],["Column",""],["ColumnConstraint",""],["ColumnConstraintOrAlternation",""],["ComputedTable","A source of rows that isn't a named table -- typically a subquery or union."],["DatomsColumn","One of the named columns of our tables."],["DatomsTable","This enum models the fixed set of default tables we have -- two tables and two views -- and computed tables defined in the enclosing CC."],["EmptyBecause",""],["FulltextColumn","One of the named columns of our fulltext values table."],["QueryValue",""],["VariableColumn",""]],"fn":[["algebrize",""],["algebrize_with_counter",""],["algebrize_with_inputs",""],["parse_find_string",""]],"macro":[["bail",""]],"struct":[["AlgebraicQuery",""],["ColumnAlternation","A `ColumnAlternation` constraint is satisfied if at least one of its inner constraints is satisfied. An empty `ColumnAlternation` is never satisfied."],["ColumnIntersection","A `ColumnIntersection` constraint is satisfied if all of its inner constraints are satisfied. An empty intersection is always satisfied."],["ConjoiningClauses","A `ConjoiningClauses` (CC) is a collection of clauses that are combined with `JOIN`.  The topmost form in a query is a `ConjoiningClauses`."],["FindQuery","A `FindQuery` represents a valid query to the query algebrizer."],["Known","A convenience wrapper around things known in memory: the schema and caches. We use a trait object here to avoid making dozens of functions generic over the type of the cache. If performance becomes a concern, we should hard-code specific kinds of cache right here, and/or eliminate the Option."],["OrderBy","Represents an entry in the ORDER BY list: a variable or a variable's type tag. (We require order vars to be projected, so we can simply use a variable here.)"],["QualifiedAlias","A particular column of a particular aliased table. E.g., \"datoms123\", Attribute."],["QueryInputs","Define the inputs to a query. This is in two parts: a set of values known now, and a set of types known now. The separate map of types is to allow queries to be algebrized without full knowledge of the bindings that will be used at execution time. When built correctly, `types` is guaranteed to contain the types of `values` -- use `QueryInputs::new` or `QueryInputs::with_values` to construct an instance."],["SourceAlias","The association between a table and its alias. E.g., AllDatoms, \"all_datoms123\"."]],"trait":[["ColumnName",""]],"type":[["Result",""],["TableAlias","A specific instance of a table within a query. E.g., \"datoms123\"."],["VariableBindings",""]]});